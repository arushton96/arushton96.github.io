{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"","tags":["tag1","tag2"]},{"location":"#introduction","title":"Introduction","text":"<p>My name is Andrew, and I am a member of team 305. This webpage is for my EGR314 Spring Semester class project.</p>","tags":["tag1","tag2"]},{"location":"#project-summary","title":"Project Summary","text":"<p>For team 305's project we are creating a line-following robot like this one. It will use color sensors to detect the location and curve of a line drawn in front of it, and servo motors to control the wheels of the machine.  Currently the plan is to 3D-print a small chassis to hold the components of the car such as the PC boards, sensors, and motors. The user will be able to interface with the robot through both an LCD screen and a Wi-Fi connection.</p>","tags":["tag1","tag2"]},{"location":"#my-contribution","title":"My contribution","text":"<p>My part in this project is to create a Wi-Fi connection using MQTT protocol. The connection will be used in part with the human-machine interface (HMI) to allow diagnostic control over the robot, as well as provide an output for different data from the machine, such as speed, processing time, battery life, and data from the sensors. As the project progresses and I discover more things I can do with MQTT, the scope of what my subsystem does might change, but for the time being it will act as a more user-friendly extension of the HMI system, and will use much of the data collected in that system.</p>","tags":["tag1","tag2"]},{"location":"#continuation","title":"Continuation","text":"<p>Feel free to please peruse through my webpage to see the current progress and workflow of my part of the project. If you would like to navigate back to the group 305's team webpage you can access it right here. There you will find our group contributions and overall structure to our project, as well as links to the individual pages of the rest of the group.</p>","tags":["tag1","tag2"]},{"location":"%201-Block-Diagram/","title":"Block Diagram","text":""},{"location":"%201-Block-Diagram/#decision-process","title":"Decision Process","text":"<p>The block diagram for my subsystem was developed based on the need for both UART message validation and MQTT-based fallback communication. Early in the design phase, the MQTT system was primarily intended to act as a relay node, but as the project progressed, its role expanded to include UART message filtering, MQTT publication, and fallback logic in the event of UART failure. The final block diagram reflects this integration of responsibilities, showing clear communication pathways between the sensor, motor, and HMI subsystems, as well as the dual-channel communication through both UART and MQTT. The inclusion of debug LEDs, state-tracking logic, and a local graphing interface helped the system fulfill reliability, visibility, and backup functionality requirements set during development.</p> <p></p> <p>Block Diagram PDF</p>"},{"location":"2-Component-Selection/","title":"Component Selection","text":""},{"location":"2-Component-Selection/#my-subsystem","title":"My Subsystem","text":"<p>I was responsible for developing the MQTT subsystem, which provided fault-tolerant communication reliability and system monitoring. The ESP32-S3-WROOM module served as the backbone for this design due to its native Wi-Fi capabilities, flexible UART support, and sufficient GPIO for expansion and debugging features.</p> <p>This subsystem was responsible for relaying messages between other boards, detecting UART failure, and forwarding valid data via MQTT. It also coordinated a system-wide response to sensor input, managed a timed lockout to prevent false stop signals, and published MQTT data that could be visualized using a Python-based local graph viewer. Debug LEDs were incorporated for status indication during startup, message processing, and system activity.</p> <p></p>"},{"location":"2-Component-Selection/#major-hardware-selection","title":"Major Hardware Selection","text":"<p>This subsystem relied primarily on the ESP32-S3-WROOM, which integrated all the features required for MQTT communication and UART relaying. No external microcontroller or Wi-Fi module was necessary due to its built-in capabilities. The only other significant component was a switching voltage regulator (buck converter) used to step down 5V USB power to the 3.3V required by the ESP32.</p> <p>While passive components like resistors and capacitors were also included, they were part of standard best practices rather than explicit design decisions. Because the ESP32 handled all logic, message processing, and communication tasks, no additional sensors or specialized ICs were required.</p> <p></p>"},{"location":"2-Component-Selection/#design-decisions-and-justification","title":"Design Decisions and Justification","text":"<p>The MQTT board\u2019s design revolved around ensuring reliable message routing, fallback communication, and monitoring. The ESP32-S3-WROOM was selected because it could handle all UART communication and MQTT publishing without external hardware. This selection enabled robust integration and flexibility while minimizing the component count.</p> <p>A previously validated buck converter (MP1584) was reused to provide regulated 3.3V power. Although not extensively researched during this project, the module was well-known from earlier coursework and was verified to meet voltage and current demands. Other hardware choices, such as debug LEDs, were added to support troubleshooting and state visibility throughout the development process.</p> <p>Originally, this subsystem was also meant to handle the power supply and HMI coordination, but its role was later focused specifically on system communication. Final implementation included UART parsing and filtering, MQTT publishing of valid messages, automatic fallback when UART became unresponsive, and visualization of system activity using a local Python graphing tool. These decisions resulted in a stable and modular foundation for the entire system\u2019s message flow.</p> <p></p>"},{"location":"2-Component-Selection/#microcontroller-selection","title":"Microcontroller Selection","text":"ESP Info Answer Model ESP32-S3-WROOM-1 Product Page URL Product Page ESP32-S3-WROOM-1-N4 Datasheet URL Data Sheet ESP32 S3 Datasheet URL ESP32-S3 Series Datasheet ESP32 S3 Technical Reference Manual URL Technical Reference Manual Vendor link Digikey Link Code Examples PubSubLibrary WiFi Library External Resources URL(s) ESP32 MicroPython: MQTT How to setup MQTT for Raspberry Pi and ESP32 Unit cost $2.95 Absolute Maximum Current for entire IC 1500 mA Supply Voltage Range Min: 3.0V  Typical: 3.3V  Max: 3.6V Maximum GPIO current  (per pin) Not explicitly stated in datasheet, however in general around 40mA max and 20mA typical. Supports External Interrupts? Supports external interrupts which can also be used to wake from light sleep mode Required Programming Hardware, Cost, URL USD to Serial converter 5-10$ Module # Available Needed Associated Pins (or * for any) UART 2 2 Pins 10 &amp; 37 (TX)  Pins 11 &amp; 36 (RX) external SPI* 1 0 SPI 0 &amp; 1 (Reserved)  SPI 2 (Pins 18-21)  SPI 3 (Pins 27-30) I2C 2 0 * GPIO 36 0 Any except 1, 2, 3, 40 &amp; 41 ADC 20 0 ADC1 (Pins 4-7, 12, 15, 17, 18, 38, 39)  ADC2 (Pins 8-11, 13, 14, 19-22) LED PWM 36 4 * Motor PWM 36 0 * USB Programmer 1 1 Pins (13 &amp; 14 +VCC/Ground)"},{"location":"2-Component-Selection/#final-major-components-summary","title":"Final Major Components Summary","text":"Component Part Number Function ESP32-S3-WROOM ESP32-S3-WROOM-1-N8R8 Main microcontroller for MQTT, UART, Wi-Fi Buck Converter Module LM2596 Module 5V voltage regulation for board power"},{"location":"2-Component-Selection/#esp32-diagram-and-wiring","title":"ESP32 Diagram and Wiring","text":""},{"location":"3-esp-32-table/","title":"ESP32 Table","text":"ESP Info Answer Model ESP32-S3-WROOM-1 Product Page URL Product Page ESP32-S3-WROOM-1-N4 Datasheet URL Data Sheet ESP32 S3 Datasheet URL ESP32-S3 Series Datasheet ESP32 S3 Technical Reference Manual URL Technical Reference Manual Vendor link Digikey Link Code Examples PubSubLibrary WiFi Library External Resources URL(s) ESP32 MicroPython: MQTT How to setup MQTT for Raspberry Pi and ESP32 Unit cost $2.95 Absolute Maximum Current for entire IC 1500 mA Supply Voltage Range Min: 3.0V  Typical: 3.3V  Max: 3.6V Maximum GPIO current  (per pin) Not explicitly stated in datasheet, however in general around 40mA max and 20mA typical. Supports External Interrupts? Supports external interrupts which can also be used to wake from light sleep mode Required Programming Hardware, Cost, URL USD to Serial converter 5-10$ Module # Available Needed Associated Pins (or * for any) UART 2 2 Pins 10 &amp; 37 (TX)  Pins 11 &amp; 36 (RX) external SPI* 1 0 SPI 0 &amp; 1 (Reserved)  SPI 2 (Pins 18-21)  SPI 3 (Pins 27-30) I2C 2 0 * GPIO 36 ? Any except 1, 2, 3, 40 &amp; 41 ADC 20 0 ADC1 (Pins 4-7, 12, 15, 17, 18, 38, 39)  ADC2 (Pins 8-11, 13, 14, 19-22) LED PWM 36 4 * Motor PWM 36 0 * USB Programmer 1 1 Pins (13 &amp; 14 +VCC/Ground)"},{"location":"4-Bill-Of-Materials/","title":"BoM","text":"<p>Individual Schematic PDF</p>"},{"location":"5-API/","title":"Process and Solved Problems","text":"<p>The MQTT subsystem served as the second node in the UART message chain and took on the primary responsibility for message validation and filtering due to its robust communication protocol. Over the course of development, our team determined that only one type of message\u2014live sensor values\u2014needed to be propagated through the system. While sender and receiver IDs were initially planned as key routing elements, they ultimately became redundant for most subsystems. However, the MQTT system retained full protocol enforcement, which required it to remain between the sensor and motor subsystems to ensure only valid messages were processed. To support this, I adapted the receiver ID field to track whether a message had already circulated through the full UART chain. Upon receiving a valid message, the MQTT system rewrote the receiver ID to its own and filtered out any returning messages marked this way, effectively preventing duplication without altering the message structure.</p> <p>A separate challenge arose from the high frequency of sensor messages\u2014often 5 to 10 per second\u2014which could overwhelm the system and prevent the motors from restarting once a stop condition was triggered. To manage this, I implemented a timed filter that suppressed duplicate sensor messages during a defined stop interval. After this delay, the MQTT subsystem automatically resumed motor activity and introduced a secondary lockout period to prevent premature retriggering. This approach ensured reliable operation without requiring upstream changes to the sensor logic.</p> <p> </p>"},{"location":"5-API/#message-overview","title":"Message Overview","text":"Message 1 Variable Name Sensor_Value Variable Type int8_t Min Value 100 Max Value 101 Example 0x64 &amp; 0x65 <p>As written above, the only value used in the system is the live sensor value.</p> <p>The Sender and Receiver bytes are 0x01-0x04. The start byte is 0x41 and the end byte is 0x42. Our \"data\" package of the message is only 1 byte, either 0x64 or 0x65, which represent the only two colors that the sensors were coded to recognize.</p> <p>Team IDs: Sensor = 0x01 | HMI = 0x03 | Motor = 0x02 | MQTT = 0x04</p> <p> </p>"},{"location":"5-API/#message-format","title":"Message Format","text":"<p>This section demonstrates how the MQTT subsystem receives messages differently the first time versus the second time. When a sensor message is received for the first time, it arrives with the original receiver ID (0x05). The MQTT subsystem then rewrites the receiver ID to 0x04 before forwarding it. This change affects how all other subsystems receive the message as well\u2014each sees the modified version with the updated receiver ID. If the message loops back to the MQTT subsystem, the new receiver ID indicates it has already been processed once, allowing it to be identified and discarded as a duplicate.</p>"},{"location":"5-API/#first-time-message-format-before-id-change","title":"First-Time Message Format (Before ID Change)","text":"Byte 1 Byte 2 Byte 3 Byte 4 Byte 5 Byte Name Start Sender Receiver Sensor_Value End Byte Type int8_t int8_t int8_t int8_t int8_t Byte Contents 0x41 0x01 0x03 Sensor Byte 0x42"},{"location":"5-API/#second-time-message-format-after-id-change","title":"Second-Time Message Format (After ID Change)","text":"Byte 1 Byte 2 Byte 3 Byte 4 Byte 5 Byte Name Start Sender Receiver Sensor_Value End Byte Type int8_t int8_t int8_t int8_t int8_t Byte Contents 0x41 0x01 0x04 Sensor Byte 0x42"},{"location":"6-Schematic-Diagram/","title":"Schematic","text":"<p>The following schematic shows the complete design for the MQTT subsystem, including the ESP32, supporting passives, UART lines, and power connections.</p> <p></p> <p>Individual Schematic PDF</p>"},{"location":"7-PCB-Layout/","title":"PCB Layout","text":"<p>This PCB was designed for a two-layer board. Shown below are the top and bottom copper layers for the MQTT subsystem, including ESP32 placement, voltage regulation, UART connections, and debug indicators.</p>"},{"location":"7-PCB-Layout/#top-layer","title":"Top Layer","text":"<p> View Full PDF</p>"},{"location":"7-PCB-Layout/#bottom-layer","title":"Bottom Layer","text":"<p> View Full PDF</p>"},{"location":"Code/","title":"Code Overview","text":"<p>This section documents the code I developed for the MQTT subsystem, along with support code I wrote or modified for the Sensor and HMI subsystems to enable UART-to-MQTT fallback functionality.</p>"},{"location":"Code/#mqtt-subsystem","title":"MQTT Subsystem","text":"<p>This subsystem was responsible for UART message filtering, MQTT communication, and system visualization. It includes three main files:</p> <ul> <li>main.py \u2013 Core loop for UART parsing, MQTT publishing, and state control</li> <li>UART_Protocol.py \u2013 Functions to encode and decode 5-byte UART messages</li> <li>mqtt_graph_viewer.py \u2013 Python script for PC-based graphing of MQTT topic data.</li> </ul> <p>\ud83d\udcc4 View MQTT Subsystem Code</p>"},{"location":"Code/#sensor-subsystem-uart-backup","title":"Sensor Subsystem (UART Backup)","text":"<p>The following code reflects the final integrated version used for the Sensor subsystem. While the original structure was written by a teammate, I incorporated all MQTT-related functionality and UART fallback logic shown here.</p> <p>This version was tested and ready for final demonstration, and accurately represents my contribution to the subsystem. All MQTT-related sections are clearly marked in the code below. The remaining core sensor logic and I2C implementation were provided by the original developer.</p> <p>\ud83d\udcc4 View Sensor Code</p>"},{"location":"Code/#hmi-subsystem-mqtt-visualization","title":"HMI Subsystem (MQTT Visualization)","text":"<p>To support UART backup functionality and MQTT-based system visualization, I modified the HMI subsystem code to publish messages over MQTT for my subsystems use. The base structure was written by a teammate; I incorporated MQTT logic and display rendering to support testing and integration.</p> <p>The code shown here does not exactly match the final version submitted by the teammate responsible for the HMI subsystem. I rewrote portions of the code for my at-home testing environment and have highlighted the sections that reflect my contributions. These highlighted areas represent the full scope of my work on this subsystem and were functionally validated during integration.</p> <p>\ud83d\udcc4 View HMI Code</p>"},{"location":"Code/hmi-code/","title":"HMI Code","text":"<p>The following code was written by me to fully integrate the HMI subsystem with the MQTT server. While I based some structure on my teammate's earlier draft, the version below reflects a complete rewrite. I deployed it on the HMI board and verified the functionality during testing. The only reason it did not pass demonstration initially was due to incorrect UART pin settings, which were fixed later.</p> <p>This is the intended final version of the HMI code. All MQTT-related functionality and OLED updates were implemented by me.</p> <pre><code>import ssl\nfrom machine import UART, Pin, SoftI2C\nimport time\nimport uasyncio as asyncio\nfrom mqtt_as.mqtt_as import MQTTClient                      # \ud83d\udfe9 MQTT addition\nfrom mqtt_as.mqtt_local import wifi_led, blue_led, config   # \ud83d\udfe9 MQTT addition\nimport ssd1306\nimport gfx\nfrom config import *\n\n# ==== OLED Setup ====\ni2c = SoftI2C(scl=Pin(4), sda=Pin(5))\noled = ssd1306.SSD1306_I2C(128, 64, i2c)\ngraphics = gfx.GFX(128, 64, oled.pixel)\n\ndef draw_stopping():\n    oled.fill(0)\n    graphics.line(0, 0, 127, 63, 1)\n    graphics.line(127, 0, 0, 63, 1)\n    oled.show()\n\ndef draw_moving():\n    oled.fill(0)\n    graphics.fill_triangle(64, 5, 20, 58, 108, 58, 1)\n    oled.show()\n\ndraw_stopping()  # Default screen on boot\n\n# ==== UART Setup ====\nuart = UART(2, baudrate=9600, tx=43, rx=44)\nSTART_BYTE = 0x41\nSENDER_ID = 0x03\nEND_BYTE = 0x42\n\n# ==== MQTT Setup ====                                      # \ud83d\udfe9 MQTT addition\nconfig['ssid'] = 'photon'\nconfig['wifi_pw'] = 'particle'\nconfig['server'] = 'mqtt.eclipseprojects.io'\nconfig['port'] = 1883\nconfig['ssl'] = False\nconfig['clean'] = True\n\nMQTTClient.DEBUG = True                                     # \ud83d\udfe9 MQTT addition\nclient = MQTTClient(config)\n\n# ==== UART Listener ====\nasync def uart_loop():\n    while True:\n        if uart.any() &gt;= 5:\n            msg = uart.read(5)\n            if msg and len(msg) == 5 and msg[0] == START_BYTE and msg[4] == END_BYTE:\n                print(\"UART Received:\", [hex(b) for b in msg])\n                data = msg[3]\n\n                if data == 0x00:\n                    draw_stopping()\n                elif data == 0x01:\n                    draw_moving()\n\n                await client.publish(\"hmi/uart_data\", str([hex(b) for b in msg]), qos=1)  # \ud83d\udfe9 MQTT addition\n\n        await asyncio.sleep(0.1)\n\n# ==== MQTT Subscriber Callback ====                         # \ud83d\udfe9 MQTT addition\ndef sub_cb(topic, msg, retained):\n    try:\n        value = int(msg.decode())\n        print(\"MQTT Received:\", value)\n        if value == 0:\n            draw_stopping()\n        elif value == 1:\n            draw_moving()\n    except Exception as e:\n        print(\"MQTT decode error:\", e)\n\nconfig['subs_cb'] = sub_cb                                   # \ud83d\udfe9 MQTT addition\n\n# ==== Main Startup ====\nasync def main():\n    print(\"Connecting to MQTT...\")                           # \ud83d\udfe9 MQTT addition\n    while True:\n        try:\n            await client.connect()\n            print(\"\u2705 Connected to MQTT\")\n            break\n        except Exception as e:\n            print(\"\u274c MQTT connect failed:\", repr(e))\n            await asyncio.sleep(2)\n\n    await client.subscribe(\"car/state\", 1)                   # \ud83d\udfe9 MQTT addition\n    print(\"Subscribed to car/state\")\n\n    asyncio.create_task(uart_loop())\n\n    while True:\n        await asyncio.sleep(1)\n\ntry:\n    asyncio.run(main())\nfinally:\n    client.close()                                           # \ud83d\udfe9 MQTT addition\n</code></pre>"},{"location":"Code/sensor-code/","title":"Sensor Code","text":"<p>The following code integrates the original sensor functionality written by my teammate with MQTT fallback logic that I implemented. This version reflects the final, fully functional integration that was intended to run during demonstration.</p> <p>MQTT-related sections are clearly marked to indicate my specific contributions.</p> <pre><code>import time\nimport uasyncio as asyncio\nfrom machine import SoftI2C, Pin, UART\nfrom mqtt_as.mqtt_as import MQTTClient                          # \ud83d\udfe9 MQTT addition\nfrom mqtt_as.mqtt_local import config                           # \ud83d\udfe9 MQTT addition\n\n# I2C and sensor setup\ni2c = SoftI2C(scl=Pin(9), sda=Pin(8), freq=100000)\nOPT4060_ADDR = 0x44\n\n# LED\nled = Pin(15, Pin.OUT)\n\n# UART2 on GPIO 47 (TX), GPIO 46 (RX)\nuart = UART(2, baudrate=9600, tx=Pin(47), rx=Pin(46))\n\n# Protocol constants\nSTART = 0x41\nEND = 0x42\nSENDER_ID = 0x01\nRECEIVER_ID = 0x03\nRED_MSG = 0x64\nBLUE_MSG = 0x65\n\n# ==== MQTT Configuration ====                                 # \ud83d\udfe9 MQTT addition\nconfig['ssid'] = 'phpton'\nconfig['wifi_pw'] = 'particle'\nconfig['server'] = 'mqtt.eclipseprojects.io'\nconfig['port'] = 1883\nconfig['ssl'] = False\nconfig['clean'] = True\nconfig['subs_cb'] = None\nMQTTClient.DEBUG = True\nclient = MQTTClient(config)\n\n# ==== Fallback Logic ====                                     # \ud83d\udfe9 MQTT addition\nuart_last_seen = time.ticks_ms()\nFALLBACK_TIMEOUT = 15000  # 15 seconds\nmqtt_fallback_active = False\n\ndef send_message(receiver_id, data_byte):\n    msg = bytes([START, SENDER_ID, receiver_id, data_byte, END])\n    uart.write(msg)\n    print(\"Sent to UART:\", [hex(b) for b in msg])\n\ndef read_uart():\n    global uart_last_seen\n    if uart.any() &gt;= 5:\n        msg = uart.read(5)\n        if msg and len(msg) == 5 and msg[0] == START and msg[4] == END:\n            print(\"UART Received:\", [hex(b) for b in msg])\n            uart_last_seen = time.ticks_ms()\n            return msg\n    return None\n\n# ==== MQTT Fallback Watchdog ====                              # \ud83d\udfe9 MQTT addition\nasync def check_mqtt_fallback():\n    global mqtt_fallback_active\n    while True:\n        if time.ticks_diff(time.ticks_ms(), uart_last_seen) &gt; FALLBACK_TIMEOUT:\n            if not mqtt_fallback_active:\n                mqtt_fallback_active = True\n                print(\"MQTT fallback mode ENABLED\")\n                await client.subscribe('hmi/uart_data', 1)\n        await asyncio.sleep(1)\n\n# ==== MQTT Message Handler ====                                # \ud83d\udfe9 MQTT addition\nasync def handle_mqtt_messages(topic, msg, retained):\n    global uart_last_seen\n    if not mqtt_fallback_active:\n        return\n\n    try:\n        values = eval(msg.decode())\n        if isinstance(values, list) and len(values) == 5 and values[0] == '0x41' and values[4] == '0x42':\n            parsed = [int(v, 16) for v in values]\n            print(\"Forwarding MQTT message:\", values)\n            uart.write(bytes(parsed))\n            uart_last_seen = time.ticks_ms()\n    except Exception as e:\n        print(\"Error parsing MQTT message:\", e)\n\nconfig['subs_cb'] = handle_mqtt_messages                       # \ud83d\udfe9 MQTT addition\n\n# ==== Sensor Main Loop ====\nasync def sensor_loop():\n    while True:\n        read_uart()  # Check for incoming UART messages\n\n        # Color sensor capture\n        try:\n            i2c.writeto(OPT4060_ADDR, bytes([0x0A, 0x30, 0x78]))\n            time.sleep_ms(100)\n            i2c.writeto(OPT4060_ADDR, bytes([0x00]))\n            data = i2c.readfrom(OPT4060_ADDR, 16)\n\n            red   = ((data[0] &amp; 0x0F) &lt;&lt; 8) | data[1]\n            green = ((data[4] &amp; 0x0F) &lt;&lt; 8) | data[5]\n            blue  = ((data[8] &amp; 0x0F) &lt;&lt; 8) | data[9]\n\n            print(\"Red:\", red, \"Green:\", green, \"Blue:\", blue)\n\n            if red &gt; green and red &gt; blue and red &gt; 200:\n                print(\"\ud83d\udd34 Red detected\")\n                led.on()\n                await asyncio.sleep(0.2)\n                led.off()\n                await asyncio.sleep(0.2)\n                send_message(RECEIVER_ID, RED_MSG)\n\n            elif blue &gt; red and blue &gt; green and blue &gt; 200:\n                print(\"\ud83d\udd35 Blue detected\")\n                led.on()\n                await asyncio.sleep(0.2)\n                led.off()\n                await asyncio.sleep(0.2)\n                send_message(RECEIVER_ID, BLUE_MSG)\n\n            else:\n                led.off()\n                await asyncio.sleep(0.5)\n\n        except Exception as e:\n            print(\"Sensor read error:\", e)\n            await asyncio.sleep(1)\n\n# ==== Main Entry Point ====                                    # \ud83d\udfe9 MQTT addition\nasync def main():\n    print(\"Connecting to MQTT...\")\n    while True:\n        try:\n            await client.connect()\n            print(\"MQTT Connected\")\n            break\n        except Exception as e:\n            print(\"MQTT connect failed:\", e)\n            await asyncio.sleep(2)\n\n    asyncio.create_task(check_mqtt_fallback())\n    await sensor_loop()\n\ntry:\n    asyncio.run(main())\nfinally:\n    client.close()                                              # \ud83d\udfe9 MQTT addition\n</code></pre>"},{"location":"Code/mqtt-code/","title":"MQTT Subsystem Code","text":"<p>This section contains all code related to the MQTT subsystem, including both embedded logic running on the ESP32 and a separate Python script used for real-time visualization on a local computer.</p>"},{"location":"Code/mqtt-code/#files","title":"Files","text":"<ul> <li>main.py: Core firmware logic for UART filtering, MQTT publishing, and system control.</li> <li>uart_protocol.py: Utility functions to encode and decode 5-byte UART messages.</li> <li>mqtt_graph_viewer.py: Python script for PC-based graphing of MQTT topic data.</li> </ul>"},{"location":"Code/mqtt-code/graph-viewer/","title":"mqtt_graph_viewer.py","text":"<p>This Python script was developed to run on a PC for real-time monitoring and visualization of MQTT data during testing and demonstration.</p> <p>It subscribes to key MQTT topics and plots: - Robot car movement state (start/stop) - Count of terminated messages (loopback detected) - Count of redundant messages (excess sensor triggers)</p> <p>This is not embedded code \u2014 it was designed as a local tool to support development and debugging of the MQTT subsystem.</p> <pre><code>import matplotlib.pyplot as plt\nimport matplotlib.animation as animation\nfrom collections import deque\nimport paho.mqtt.client as mqtt\n\n# MQTT Configuration\nBROKER = \"mqtt.eclipseprojects.io\"\nPORT = 1883\nTOPICS = [(\"car/state\", 0), (\"counter/terminated\", 0), (\"counter/redundant\", 0)]\n\n# Plot data\nMAX_POINTS = 100\nmovement_data = deque([0]*MAX_POINTS, maxlen=MAX_POINTS)\nterminated_count = deque([0]*MAX_POINTS, maxlen=MAX_POINTS)\nredundant_count = deque([0]*MAX_POINTS, maxlen=MAX_POINTS)\n\n# Current values to plot\ncurrent_terminated = 0\ncurrent_redundant = 0\n\ndef on_connect(client, userdata, flags, rc):\n    if rc == 0:\n        print(\"Connected to MQTT broker.\")\n        for topic, qos in TOPICS:\n            client.subscribe(topic)\n    else:\n        print(f\"Failed to connect, return code {rc}\")\n\ndef on_message(client, userdata, msg):\n    global current_terminated, current_redundant\n\n    topic = msg.topic\n    payload = msg.payload.decode()\n\n    if topic == \"car/state\":\n        if payload == \"1\":\n            movement_data.append(1)\n        elif payload == \"0\":\n            movement_data.append(-1)\n        else:\n            movement_data.append(0)\n    elif topic == \"counter/terminated\":\n        try:\n            current_terminated = int(payload)\n        except ValueError:\n            pass\n    elif topic == \"counter/redundant\":\n        try:\n            current_redundant = int(payload)\n        except ValueError:\n            pass\n\ndef update_plot(frame):\n    terminated_count.append(current_terminated)\n    redundant_count.append(current_redundant)\n\n    ax1.clear()\n    ax1.plot(movement_data, label=\"Car State\")\n    ax1.set_ylim([-1.5, 1.5])\n    ax1.set_title(\"Robot Car State (1 = Moving, -1 = Stopped)\")\n    ax1.grid(True)\n    ax1.legend(loc=\"upper right\")\n\n    ax2.clear()\n    ax2.plot(terminated_count, label=\"Terminated Messages\")\n    ax2.plot(redundant_count, label=\"Redundant Messages\")\n    ax2.set_title(\"MQTT Message Counters\")\n    ax2.set_xlabel(\"Time\")\n    ax2.grid(True)\n    ax2.legend(loc=\"upper left\")\n\n# MQTT Setup\nclient = mqtt.Client()\nclient.on_connect = on_connect\nclient.on_message = on_message\nclient.connect(BROKER, PORT, 60)\nclient.loop_start()\n\n# Matplotlib Setup\nfig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 6))\nani = animation.FuncAnimation(fig, update_plot, interval=500)\nplt.tight_layout()\nplt.show()\n</code></pre>"},{"location":"Code/mqtt-code/main/","title":"main.py \u2014 MQTT Subsystem Firmware","text":"<p>This file contains the full firmware for the MQTT subsystem. It handles UART communication, message filtering, and MQTT publishing, as well as timed control logic for forwarding and managing stop/start signals to the motor system.</p> <pre><code>import ssl\nfrom mqtt_as.mqtt_as import MQTTClient\nfrom mqtt_as.mqtt_local import wifi_led, blue_led, config\nimport uasyncio as asyncio\nfrom machine import UART, Pin\nimport time\nfrom config import *\n\nSTART_BYTE = 0x41\nEND_BYTE = 0x42\nPACKET_SIZE = 5\n\n# Debug LEDs\nled_start  = Pin(39, Pin.OUT)\nled_wifi   = Pin(40, Pin.OUT)\nled_mqtt   = Pin(41, Pin.OUT)\nled_alive  = Pin(42, Pin.OUT)\n\nasync def flash_led(led, duration=0.2):\n    led.on()\n    await asyncio.sleep(duration)\n    led.off()\n\nconfig['ssid'] = 'photon'\nconfig['wifi_pw'] = 'particle'\nconfig['server'] = 'mqtt.eclipseprojects.io'\nconfig['port'] = 1883\nconfig['ssl'] = False\nconfig['clean'] = True\nconfig['subs_cb'] = lambda t, m, r: print(\"MSG:\", m.decode())\nMQTTClient.DEBUG = True\nclient = MQTTClient(config)\n\nuart = UART(1, baudrate=9600, tx=43, rx=44)\n\nwhile uart.any():\n    uart.read()\n\nasync def uart_listener():\n    buffer = bytearray()\n    reader = asyncio.StreamReader(uart)\n\n    lockout = False\n    grace_period = False\n    repeat_counter = 0\n\n    asyncio.create_task(alive_flasher())\n\n    while True:\n        byte = await reader.read(1)\n        await asyncio.sleep(0.01)\n\n        if byte:\n            buffer.append(byte[0])\n            print(f\"Received byte: 0x{byte[0]:02X}\")\n\n            if len(buffer) == PACKET_SIZE:\n                start, sender, receiver, data, end = buffer\n                print(\"Full UART message:\", [f\"0x{b:02X}\" for b in buffer])\n\n                if start == START_BYTE and end == END_BYTE and sender in (0x01, 0x03, 0x04, 0x05) and receiver in (0x01, 0x03, 0x04, 0x05):\n\n                    # Handle STOP triggers (0x64 or 0x65)\n                    if data in (0x64, 0x65):\n                        if not lockout and not grace_period:\n                            print(\"STOP received \u2014 initiating lockout\")\n                            lockout = True\n                            repeat_counter = 0\n\n                            # Send STOP\n                            stop_msg = bytes([START_BYTE, 0x04, 0x05, 0x00, END_BYTE])\n                            uart.write(stop_msg)\n                            await client.publish(\"car/state\", b\"0\", qos=1)\n\n                            await asyncio.sleep(5)\n\n                            # Send GO\n                            go_msg = bytes([START_BYTE, 0x04, 0x05, 0x01, END_BYTE])\n                            uart.write(go_msg)\n                            await client.publish(\"car/state\", b\"1\", qos=1)\n\n                            # Grace period begins\n                            grace_period = True\n                            lockout = False\n                            await asyncio.sleep(2)\n                            grace_period = False\n\n                            while uart.any():\n                                uart.read()\n\n                        else:\n                            repeat_counter += 1\n                            print(f\"Ignored repeat stop (count = {repeat_counter})\")\n\n                    elif receiver == 0x05:\n                        print(\"Message terminated at MQTT\")\n                        await client.publish(\"car/terminated\", b\"1\", qos=0)\n\n                    else:\n                        buffer[2] = 0x05\n                        uart.write(buffer)\n                        print(\"Forwarded message with receiver updated to 0x05\")\n\n                else:\n                    print(\"Invalid message structure or IDs\")\n                    await client.publish(\"car/invalid\", b\"1\", qos=0)\n\n                buffer[:] = b''\n\nasync def alive_flasher():\n    while True:\n        led_alive.on()\n        await asyncio.sleep(0.1)\n        led_alive.off()\n        await asyncio.sleep(9.9)\n\nasync def main():\n    print(\"Step 1: Starting script\")\n    await flash_led(led_start)\n\n    print(\"Step 2: Connecting to MQTT...\")\n    mqtt_attempts = 0\n    while True:\n        try:\n            await client.connect()\n            print(\"Connected to MQTT\")\n            await flash_led(led_wifi)\n            await flash_led(led_mqtt)\n            break\n        except Exception as e:\n            mqtt_attempts += 1\n            print(f\"MQTT connect failed ({mqtt_attempts}):\", repr(e))\n            await asyncio.sleep(2)\n\n    print(\"Step 3: MQTT ready, starting UART...\")\n    asyncio.create_task(uart_listener())\n\n    while True:\n        await asyncio.sleep(1)\n\ntry:\n    asyncio.run(main())\nfinally:\n    client.close()\n</code></pre>"},{"location":"Code/mqtt-code/uart-protocol/","title":"uart_protocol.py","text":"<p>This module defines the UART message protocol for the MQTT subsystem. It provides functions for encoding and decoding 5-byte messages, including full validation of structure, sender/receiver IDs, and data integrity.</p> <pre><code>from machine import UART\nimport time\n\nSTART = 0x41\nEND = 0x42\nSENDER = 0x04  # This device\u2019s ID\n\ndef send_message(uart, receiver, data):\n    # Accept int or hex string\n    if isinstance(data, str):\n        try:\n            data = int(data, 0)\n        except ValueError:\n            raise ValueError(\"Data must be an integer or hex string\")\n\n    if not (0 &lt;= data &lt;= 255):\n        raise ValueError(\"Data must be a single byte (0\u2013255)\")\n\n    msg = bytes([START, SENDER, receiver, data, END])\n    uart.write(msg)\n    print(\"Sent:\", [f\"0x{b:02X}\" for b in msg])\n\n\ndef read_message(uart):\n    while uart.any():\n        start = uart.read(1)\n        if not start or start[0] != START:\n            continue\n\n        rest = b''\n        timeout = 1000\n        start_time = time.ticks_ms()\n\n        while len(rest) &lt; 4:\n            if uart.any():\n                rest += uart.read(1)\n            elif time.ticks_diff(time.ticks_ms(), start_time) &gt; timeout:\n                print(\"Timed out waiting for full message.\")\n                return None, None, None, None, False\n\n        msg = bytes([START]) + rest\n\n        if msg[4] != END:\n            print(\"Invalid packet structure:\", [hex(b) for b in msg])\n            return None, None, None, msg, False\n\n        sender = msg[1]\n        receiver = msg[2]\n        data = msg[3]\n\n        if sender not in (0x01, 0x02, 0x03, 0x04) or receiver not in (0x01, 0x02, 0x03, 0x04):\n            print(\"Invalid sender or receiver value:\", [hex(b) for b in msg])\n            return None, None, None, msg, False\n\n        if not (0 &lt;= data &lt;= 255):\n            print(\"Invalid data value (not a byte):\", [hex(b) for b in msg])\n            return None, None, None, msg, False\n\n        if receiver == SENDER:\n            print(\"Message Received:\")\n            print(f\"  Sender  : 0x{sender:02X}\")\n            print(f\"  Receiver: 0x{receiver:02X}\")\n            print(f\"  Data    : 0x{data:02X} ({chr(data)})\")\n\n        return sender, receiver, data, msg, True\n\n    return None, None, None, None, False\n</code></pre>"},{"location":"static/node_modules/mathjax/","title":"MathJax","text":""},{"location":"static/node_modules/mathjax/#beautiful-math-in-all-browsers","title":"Beautiful math in all browsers","text":"<p>MathJax is an open-source JavaScript display engine for LaTeX, MathML, and AsciiMath notation that works in all modern browsers.  It was designed with the goal of consolidating the recent advances in web technologies into a single, definitive, math-on-the-web platform supporting the major browsers and operating systems.  It requires no setup on the part of the user (no plugins to download or software to install), so the page author can write web documents that include mathematics and be confident that users will be able to view it naturally and easily.  Simply include MathJax and some mathematics in a web page, and MathJax does the rest.</p> <p>Some of the main features of MathJax include:</p> <ul> <li> <p>High-quality display of LaTeX, MathML, and AsciiMath notation in HTML pages</p> </li> <li> <p>Supported in most browsers with no plug-ins, extra fonts, or special   setup for the reader</p> </li> <li> <p>Easy for authors, flexible for publishers, extensible for developers</p> </li> <li> <p>Supports math accessibility, cut-and-paste interoperability, and other   advanced functionality</p> </li> <li> <p>Powerful API for integration with other web applications</p> </li> </ul> <p>See http://www.mathjax.org/ for additional details about MathJax, and https://docs.mathjax.org for the MathJax documentation.</p>"},{"location":"static/node_modules/mathjax/#mathjax-components","title":"MathJax Components","text":"<p>MathJax version 3 uses files called components that contain the various MathJax modules that you can include in your web pages or access on a server through NodeJS.  Some components combine all the pieces you need to run MathJax with one or more input formats and a particular output format, while other components are pieces that can be loaded on demand when needed, or by a configuration that specifies the pieces you want to combine in a custom way.  For usage instructions, see the MathJax documentation.</p> <p>Components provide a convenient packaging of MathJax's modules, but it is possible for you to form your own custom components, or to use MathJax's modules directly in a node application on a server.  There are web examples showing how to use MathJax in web pages and how to build your own components, and node examples illustrating how to use components in node applications or call MathJax modules directly.</p>"},{"location":"static/node_modules/mathjax/#whats-in-this-repository","title":"What's in this Repository","text":"<p>This repository contains only the component files for MathJax, not the source code for MathJax (which are available in a separate MathJax source repository).  These component files are the ones served by the CDNs that offer MathJax to the web.  In version 2, the files used on the web were also the source files for MathJax, but in version 3, the source files are no longer on the CDN, as they are not what are run in the browser.</p> <p>The components are stored in the <code>es5</code> directory, and are in ES5 format for the widest possible compatibility.  In the future, we may make an <code>es6</code> directory containing ES6 versions of the components.</p>"},{"location":"static/node_modules/mathjax/#installation-and-use","title":"Installation and Use","text":""},{"location":"static/node_modules/mathjax/#using-mathjax-components-from-a-cdn-on-the-web","title":"Using MathJax components from a CDN on the web","text":"<p>If you are loading MathJax from a CDN into a web page, there is no need to install anything.  Simply use a <code>script</code> tag that loads MathJax from the CDN.  E.g.,</p> <pre><code>&lt;script id=\"MathJax-script\" async src=\"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js\"&gt;&lt;/script&gt;\n</code></pre> <p>See the MathJax documentation, the MathJax Web Demos, and the MathJax Component Repository for more information.</p>"},{"location":"static/node_modules/mathjax/#hosting-your-own-copy-of-the-mathjax-components","title":"Hosting your own copy of the MathJax Components","text":"<p>If you want to host MathJax from your own server, you can do so by installing the <code>mathjax</code> package using <code>npm</code> and moving the <code>es5</code> directory to an appropriate location on your server:</p> <pre><code>npm install mathjax@3\nmv node_modules/mathjax/es5 &lt;path-to-server-location&gt;/mathjax\n</code></pre> <p>Note that we are still making updates to version 2, so include <code>@3</code> when you install, since the latest chronological version may not be version 3.</p> <p>Alternatively, you can get the files via GitHub:</p> <pre><code>git clone https://github.com/mathjax/MathJax.git mj-tmp\nmv mj-tmp/es5 &lt;path-to-server-location&gt;/mathjax\nrm -rf mj-tmp\n</code></pre> <p>Then (in either case) you can use a script tag like the following:</p> <pre><code>&lt;script id=\"MathJax-script\" async src=\"&lt;url-to-your-site&gt;/mathjax/tex-chtml.js\"&gt;&lt;/script&gt;\n</code></pre> <p>where <code>&lt;url-to-your-site&gt;</code> is replaced by the URL to the location where you moved the MathJax files above.</p> <p>See the documentation for details.</p>"},{"location":"static/node_modules/mathjax/#using-mathjax-components-in-a-node-application","title":"Using MathJax components in a node application","text":"<p>To use MathJax components in a node application, install the <code>mathjax</code> package:</p> <pre><code>npm install mathjax@3\n</code></pre> <p>(we are still making updates to version 2, so you should include <code>@3</code> since the latest chronological version may not be version 3).</p> <p>Then require <code>mathjax</code> within your application:</p> <pre><code>require('mathjax').init({ ... }).then((MathJax) =&gt; { ... });\n</code></pre> <p>where the first <code>{ ... }</code> is a MathJax configuration, and the second <code>{ ... }</code> is the code to run after MathJax has been loaded.  E.g.</p> <pre><code>require('mathjax').init({\nloader: {load: ['input/tex', 'output/svg']}\n}).then((MathJax) =&gt; {\nconst svg = MathJax.tex2svg('\\\\frac{1}{x^2-1}', {display: true});\nconsole.log(MathJax.startup.adaptor.outerHTML(svg));\n}).catch((err) =&gt; console.log(err.message));\n</code></pre> <p>Note: this technique is for node-based application only, not for browser applications.  This method sets up an alternative DOM implementation, which you don't need in the browser, and tells MathJax to use node's <code>require()</code> command to load external modules.  This setup will not work properly in the browser, even if you webpack it or bundle it in other ways.</p> <p>See the documentation and the MathJax Node Repository for more details.</p>"},{"location":"static/node_modules/mathjax/#reducing-the-size-of-the-components-directory","title":"Reducing the Size of the Components Directory","text":"<p>Since the <code>es5</code> directory contains all the component files, so if you are only planning one use one configuration, you can reduce the size of the MathJax directory by removing unused components. For example, if you are using the <code>tex-chtml.js</code> component, then you can remove the <code>tex-mml-chtml.js</code>, <code>tex-svg.js</code>, <code>tex-mml-svg.js</code>, <code>tex-chtml-full.js</code>, and <code>tex-svg-full.js</code> configurations, which will save considerable space.  Indeed, you should be able to remove everything other than <code>tex-chtml.js</code>, and the <code>input/tex/extensions</code>, <code>output/chtml/fonts/woff-v2</code>, <code>adaptors</code>, <code>a11y</code>, and <code>sre</code> directories.  If you are using the results only on the web, you can remove <code>adaptors</code> as well.</p> <p>If you are not using A11Y support (e.g., speech generation, or semantic enrichment), then you can remove <code>a11y</code> and <code>sre</code> as well (though in this case you may need to disable the assistive tools in the MathJax contextual menu in order to avoid MathJax trying to load them when they aren't there).</p> <p>If you are using SVG rather than CommonHTML output (e.g., <code>tex-svg.js</code> rather than <code>tex-chtml.js</code>), you can remove the <code>output/chtml/fonts/woff-v2</code> directory.  If you are using MathML input rather than TeX (e.g., <code>mml-chtml.js</code> rather than <code>tex-chtml.js</code>), then you can remove <code>input/tex/extensions</code> as well.</p>"},{"location":"static/node_modules/mathjax/#the-component-files-and-pull-requests","title":"The Component Files and Pull Requests","text":"<p>The <code>es5</code> directory is generated automatically from the contents of the MathJax source repository.  You can rebuild the components using the command</p> <pre><code>npm run make-es5 --silent\n</code></pre> <p>Note that since the contents of this repository are generated automatically, you should not submit pull requests that modify the contents of the <code>es5</code> directory.  If you wish to submit a modification to MathJax, you should make a pull request in the MathJax source repository.</p>"},{"location":"static/node_modules/mathjax/#mathjax-community","title":"MathJax Community","text":"<p>The main MathJax website is http://www.mathjax.org, and it includes announcements and other important information.  A MathJax user forum for asking questions and getting assistance is hosted at Google, and the MathJax bug tracker is hosted at GitHub.</p> <p>Before reporting a bug, please check that it has not already been reported.  Also, please use the bug tracker (rather than the help forum) for reporting bugs, and use the user's forum (rather than the bug tracker) for questions about how to use MathJax.</p>"},{"location":"static/node_modules/mathjax/#mathjax-resources","title":"MathJax Resources","text":"<ul> <li>MathJax Documentation</li> <li>MathJax Components</li> <li>MathJax Source Code</li> <li>MathJax Web Examples</li> <li>MathJax Node Examples</li> <li>MathJax Bug Tracker</li> <li>MathJax Users' Group</li> </ul>"}]}